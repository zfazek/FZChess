!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ALFABETA	./Chess.h	11;"	d
BISHOP1	./Chess.cpp	/^    KNIGHT1, KNIGHT2, BISHOP1, BISHOP2, ROOK1, ROOK2, QUEEN, KING};$/;"	e	enum:figures	file:
BISHOP2	./Chess.cpp	/^    KNIGHT1, KNIGHT2, BISHOP1, BISHOP2, ROOK1, ROOK2, QUEEN, KING};$/;"	e	enum:figures	file:
BLACK	./Chess.h	/^        int BLACK; \/\/TODO delete$/;"	m	class:Chess
BLACK	./Table.h	/^        int BLACK = -1;$/;"	m	class:Table
Bishop	./Table.h	/^        int Bishop = 3;$/;"	m	class:Table
BlackBishop	./Table.h	/^        const int BlackBishop = 0x83;$/;"	m	class:Table
BlackKing	./Table.h	/^        const int BlackKing   = 0x86;$/;"	m	class:Table
BlackKnight	./Table.h	/^        const int BlackKnight = 0x82;$/;"	m	class:Table
BlackPawn	./Table.h	/^        const int BlackPawn   = 0x81;$/;"	m	class:Table
BlackQueen	./Table.h	/^        const int BlackQueen  = 0x85;$/;"	m	class:Table
BlackRook	./Table.h	/^        const int BlackRook   = 0x84;$/;"	m	class:Table
Chess	./Chess.cpp	/^Chess::Chess() {$/;"	f	class:Chess
Chess	./Chess.h	/^class Chess {$/;"	c
DEBUG	./Chess.h	/^        int DEBUG;$/;"	m	class:Chess
DRAW	./Eval.h	/^        const int DRAW =  0;$/;"	m	class:Eval
Eval	./Eval.cpp	/^Eval::Eval(Chess* ch) {$/;"	f	class:Eval
Eval	./Eval.h	/^class Eval {$/;"	c
FZChess	./Chess.h	/^        int FZChess; \/\/ 1:white, -1:black$/;"	m	class:Chess
HASH	./Chess.h	10;"	d
HASHSIZE	./Hash.cpp	/^const unsigned int HASHSIZE = 1024 * 1024 * 64;$/;"	v
HASHSIZE_INNER	./Hash.cpp	/^const unsigned int HASHSIZE_INNER = 1024 * 1024 * 1;$/;"	v
Hash	./Hash.cpp	/^Hash::Hash() {$/;"	f	class:Hash
Hash	./Hash.h	/^class Hash {$/;"	c
KING	./Chess.cpp	/^    KNIGHT1, KNIGHT2, BISHOP1, BISHOP2, ROOK1, ROOK2, QUEEN, KING};$/;"	e	enum:figures	file:
KNIGHT1	./Chess.cpp	/^    KNIGHT1, KNIGHT2, BISHOP1, BISHOP2, ROOK1, ROOK2, QUEEN, KING};$/;"	e	enum:figures	file:
KNIGHT2	./Chess.cpp	/^    KNIGHT1, KNIGHT2, BISHOP1, BISHOP2, ROOK1, ROOK2, QUEEN, KING};$/;"	e	enum:figures	file:
King	./Table.h	/^        int King   = 6;$/;"	m	class:Table
Knight	./Table.h	/^        int Knight = 2;$/;"	m	class:Table
LOST	./Eval.h	/^        const int LOST = -22000;$/;"	m	class:Eval
MAX_LEGAL_MOVES	./Chess.h	17;"	d
MAX_MOVES	./Chess.h	16;"	d
OFFBOARD	./Table.h	4;"	d
PAWN1	./Chess.cpp	/^enum figures { PAWN1, PAWN2, PAWN3, PAWN4, PAWN5, PAWN6, PAWN7, PAWN8,$/;"	e	enum:figures	file:
PAWN2	./Chess.cpp	/^enum figures { PAWN1, PAWN2, PAWN3, PAWN4, PAWN5, PAWN6, PAWN7, PAWN8,$/;"	e	enum:figures	file:
PAWN3	./Chess.cpp	/^enum figures { PAWN1, PAWN2, PAWN3, PAWN4, PAWN5, PAWN6, PAWN7, PAWN8,$/;"	e	enum:figures	file:
PAWN4	./Chess.cpp	/^enum figures { PAWN1, PAWN2, PAWN3, PAWN4, PAWN5, PAWN6, PAWN7, PAWN8,$/;"	e	enum:figures	file:
PAWN5	./Chess.cpp	/^enum figures { PAWN1, PAWN2, PAWN3, PAWN4, PAWN5, PAWN6, PAWN7, PAWN8,$/;"	e	enum:figures	file:
PAWN6	./Chess.cpp	/^enum figures { PAWN1, PAWN2, PAWN3, PAWN4, PAWN5, PAWN6, PAWN7, PAWN8,$/;"	e	enum:figures	file:
PAWN7	./Chess.cpp	/^enum figures { PAWN1, PAWN2, PAWN3, PAWN4, PAWN5, PAWN6, PAWN7, PAWN8,$/;"	e	enum:figures	file:
PAWN8	./Chess.cpp	/^enum figures { PAWN1, PAWN2, PAWN3, PAWN4, PAWN5, PAWN6, PAWN7, PAWN8,$/;"	e	enum:figures	file:
PERFT	./Chess.h	12;"	d
Pawn	./Table.h	/^        int Pawn   = 1;$/;"	m	class:Table
QUEEN	./Chess.cpp	/^    KNIGHT1, KNIGHT2, BISHOP1, BISHOP2, ROOK1, ROOK2, QUEEN, KING};$/;"	e	enum:figures	file:
Queen	./Table.h	/^        int Queen  = 5;$/;"	m	class:Table
ROOK1	./Chess.cpp	/^    KNIGHT1, KNIGHT2, BISHOP1, BISHOP2, ROOK1, ROOK2, QUEEN, KING};$/;"	e	enum:figures	file:
ROOK2	./Chess.cpp	/^    KNIGHT1, KNIGHT2, BISHOP1, BISHOP2, ROOK1, ROOK2, QUEEN, KING};$/;"	e	enum:figures	file:
Rook	./Table.h	/^        int Rook   = 4;$/;"	m	class:Table
Table	./Table.cpp	/^Table::Table(Chess* ch) {$/;"	f	class:Table
Table	./Table.h	/^class Table {$/;"	c
Uci	./Uci.cpp	/^Uci::Uci(Chess* ch) {$/;"	f	class:Uci
Uci	./Uci.h	/^class Uci {$/;"	c
Util	./Util.h	/^class Util {$/;"	c
WHITE	./Chess.h	/^        int WHITE; \/\/TODO delete$/;"	m	class:Chess
WHITE	./Table.h	/^        int WHITE = 1;$/;"	m	class:Table
WON	./Eval.h	/^        const int WON  =  22000;$/;"	m	class:Eval
WhiteBishop	./Table.h	/^        const int WhiteBishop = 3;$/;"	m	class:Table
WhiteKing	./Table.h	/^        const int WhiteKing   = 6;$/;"	m	class:Table
WhiteKnight	./Table.h	/^        const int WhiteKnight = 2;$/;"	m	class:Table
WhitePawn	./Table.h	/^        const int WhitePawn   = 1;$/;"	m	class:Table
WhiteQueen	./Table.h	/^        const int WhiteQueen  = 5;$/;"	m	class:Table
WhiteRook	./Table.h	/^        const int WhiteRook   = 4;$/;"	m	class:Table
alfabeta	./Chess.cpp	/^int Chess::alfabeta(int dpt, int alfa, int beta) {$/;"	f	class:Chess
append_legal_moves	./Table.cpp	/^void Table::append_legal_moves(int dir_piece, int i, int j, int kk) {$/;"	f	class:Table
append_legal_moves_inner	./Table.cpp	/^void Table::append_legal_moves_inner(int dir_piece, int i, int j, int kk) {$/;"	f	class:Table
best_iterative	./Chess.h	/^        int best_iterative[MAX_LEGAL_MOVES];$/;"	m	class:Chess
best_line	./Chess.cpp	/^} best_line[99];$/;"	v	typeref:struct:best_lines
best_lines	./Chess.cpp	/^struct best_lines {$/;"	s	file:
best_move	./Chess.h	/^        int best_move;$/;"	m	class:Chess
black_double_bishops	./Chess.h	/^            int black_double_bishops;$/;"	m	struct:Chess::move
black_king_castled	./Chess.h	/^            int black_king_castled;$/;"	m	struct:Chess::move
calculate_evarray	./Chess.cpp	/^void Chess::calculate_evarray() {$/;"	f	class:Chess
calculate_evarray_new	./Chess.cpp	/^void Chess::calculate_evarray_new() {$/;"	f	class:Chess
cant_castle	./Eval.h	/^        int cant_castle        =  -10;$/;"	m	class:Eval
captured_figure	./Chess.h	/^            int captured_figure;$/;"	m	struct:Chess::move
castle	./Chess.h	/^            int castle;$/;"	m	struct:Chess::move
castling	./Table.cpp	/^void Table::castling() {$/;"	f	class:Table
checkup	./Chess.cpp	/^void Chess::checkup() {$/;"	f	class:Chess
chess	./Eval.h	/^		Chess* chess;$/;"	m	class:Eval
chess	./Table.h	/^        Chess* chess;$/;"	m	class:Table
chess	./Uci.h	/^        Chess* chess;$/;"	m	class:Uci
color	./Chess.h	/^            int color;$/;"	m	struct:Chess::move
conv0	./Table.cpp	/^int Table::conv0(int k) {$/;"	f	class:Table
convA	./Table.cpp	/^int Table::convA(int k) {$/;"	f	class:Table
curr_depth	./Chess.h	/^        int depth, seldepth, init_depth, curr_depth, curr_seldepth, gui_depth;$/;"	m	class:Chess
curr_line	./Chess.h	/^        int curr_line[MAX_LEGAL_MOVES];$/;"	m	class:Chess
curr_seldepth	./Chess.h	/^        int depth, seldepth, init_depth, curr_depth, curr_seldepth, gui_depth;$/;"	m	class:Chess
debugfile	./Chess.h	/^        FILE *debugfile;$/;"	m	class:Chess
depth	./Chess.h	/^        int depth, seldepth, init_depth, curr_depth, curr_seldepth, gui_depth;$/;"	m	class:Chess
depth	./Hash.h	/^            int depth;$/;"	m	struct:Hash::__anon2
dir_bishop	./Table.h	/^        int dir_bishop[4] = { -11,  -9,   9,  11 };$/;"	m	class:Table
dir_king	./Table.h	/^        int dir_king[8] = { -11, -10, -9, -1, 1, 9, 10, 11 };$/;"	m	class:Table
dir_knight	./Table.h	/^        int dir_knight[8] = { -21, -19, -12,  -8,  8, 12, 19, 21 };$/;"	m	class:Table
dir_rook	./Table.h	/^        int dir_rook[4] = { -10,  -1,   1,  10 };$/;"	m	class:Table
double_bishops	./Eval.h	/^        int double_bishops     =   50;$/;"	m	class:Eval
double_pawn	./Eval.h	/^        int double_pawn        =  -15;$/;"	m	class:Eval
en_passant	./Chess.h	/^            int en_passant; \/\/ eq. e3$/;"	m	struct:Chess::move
end_direction	./Table.h	/^        int end_direction;$/;"	m	class:Table
end_game_threshold	./Eval.h	/^        int end_game_threshold = 1200;$/;"	m	class:Eval
env	./Chess.h	/^        jmp_buf env;$/;"	m	class:Chess
eva_alfabeta_temp	./Chess.h	/^        int eva_alfabeta_temp[MAX_LEGAL_MOVES];$/;"	m	class:Chess
eval	./Table.h	/^        Eval* eval;$/;"	m	class:Table
evaluation	./Eval.cpp	/^int Eval::evaluation(int e_legal_pointer, int dpt) {$/;"	f	class:Eval
evaluation_king	./Eval.cpp	/^int Eval::evaluation_king(int field, int figure) {$/;"	f	class:Eval
evaluation_material	./Eval.cpp	/^int Eval::evaluation_material(int dpt) {$/;"	f	class:Eval
evaluation_only_end_game	./Eval.cpp	/^int Eval::evaluation_only_end_game(int dpt) {$/;"	f	class:Eval
evaluation_pawn	./Eval.cpp	/^int Eval::evaluation_pawn(int field, int figure, int sm) {$/;"	f	class:Eval
figure_value	./Eval.h	/^        int figure_value[7] = {0, 100, 330, 330, 500, 900, 0};$/;"	m	class:Eval
figures	./Chess.cpp	/^enum figures { PAWN1, PAWN2, PAWN3, PAWN4, PAWN5, PAWN6, PAWN7, PAWN8,$/;"	g	file:
flush	./Util.cpp	/^void Util::flush() {$/;"	f	class:Util
friendly_pawn	./Eval.h	/^        int friendly_pawn      =    5;$/;"	m	class:Eval
further	./Chess.h	/^            int further;$/;"	m	struct:Chess::move
getU	./Hash.cpp	/^int Hash::getU() {$/;"	f	class:Hash
get_ms	./Util.cpp	/^int Util::get_ms() {$/;"	f	class:Util
graphical_figure	./Table.h	/^        int graphical_figure[14][2] = {$/;"	m	class:Table
gui_depth	./Chess.h	/^        int depth, seldepth, init_depth, curr_depth, curr_seldepth, gui_depth;$/;"	m	class:Chess
hash	./Chess.h	/^        Hash* hash;$/;"	m	class:Chess
hash	./Hash.h	/^        unsigned long long hash;$/;"	m	class:Hash
hash_castle	./Hash.h	/^        unsigned long long hash_castle[15];$/;"	m	class:Hash
hash_collision	./Hash.h	/^        unsigned int hash_collision;$/;"	m	class:Hash
hash_collision_inner	./Hash.h	/^        unsigned int hash_collision_inner;$/;"	m	class:Hash
hash_enpassant	./Hash.h	/^        unsigned long long hash_enpassant[120];$/;"	m	class:Hash
hash_index	./Hash.h	/^        unsigned long long hash_index;$/;"	m	class:Hash
hash_inner	./Hash.h	/^        unsigned long long hash_inner;$/;"	m	class:Hash
hash_inner_nodes	./Hash.h	/^        unsigned int hash_inner_nodes;$/;"	m	class:Hash
hash_inner_t	./Hash.h	/^        } hash_inner_t;$/;"	t	class:Hash	typeref:struct:Hash::__anon2
hash_nodes	./Hash.h	/^        unsigned int hash_nodes;$/;"	m	class:Hash
hash_piece	./Hash.h	/^        unsigned long long hash_piece[2][7][120];$/;"	m	class:Hash
hash_rand	./Hash.cpp	/^unsigned long long Hash::hash_rand() {$/;"	f	class:Hash
hash_side_black	./Hash.h	/^        unsigned long long hash_side_black;$/;"	m	class:Hash
hash_side_white	./Hash.h	/^        unsigned long long hash_side_white;$/;"	m	class:Hash
hash_t	./Hash.h	/^        } hash_t;$/;"	t	class:Hash	typeref:struct:Hash::__anon1
hashes	./Hash.h	/^        std::map<unsigned long long, int> hashes;$/;"	m	class:Hash
hashtable	./Hash.h	/^        hash_t *hashtable;$/;"	m	class:Hash
hashtable_inner	./Hash.h	/^        hash_inner_t *hashtable_inner;$/;"	m	class:Hash
init_depth	./Chess.h	/^        int depth, seldepth, init_depth, curr_depth, curr_seldepth, gui_depth;$/;"	m	class:Chess
init_hash	./Hash.cpp	/^void Hash::init_hash() {$/;"	f	class:Hash
init_hash_inner	./Hash.cpp	/^void Hash::init_hash_inner() {$/;"	f	class:Hash
input	./Chess.h	/^        char input[1001];$/;"	m	class:Chess
invert_player_to_move	./Chess.cpp	/^void Chess::invert_player_to_move() {$/;"	f	class:Chess
is_attacked	./Table.cpp	/^int Table::is_attacked(int field, int color) {$/;"	f	class:Table
is_really_legal	./Table.cpp	/^void Table::is_really_legal() {$/;"	f	class:Table
king_castled	./Eval.h	/^        int king_castled       =   40;$/;"	m	class:Eval
last_ply	./Chess.h	/^        bool last_ply;$/;"	m	class:Chess
legal_moves	./Chess.h	/^        int legal_moves[MAX_LEGAL_MOVES];$/;"	m	class:Chess
legal_pointer	./Chess.h	/^        int legal_pointer;$/;"	m	class:Chess
length	./Chess.cpp	/^    int length;$/;"	m	struct:best_lines	file:
list_legal_moves	./Table.cpp	/^void Table::list_legal_moves() {$/;"	f	class:Table
lock	./Hash.h	/^            unsigned long long lock;$/;"	m	struct:Hash::__anon1
lock	./Hash.h	/^            unsigned long long lock;$/;"	m	struct:Hash::__anon2
main	./main.cpp	/^int main(int argc, char* argv[]) {$/;"	f
make_move	./Chess.cpp	/^void Chess::make_move() {$/;"	f	class:Chess
mate_score	./Chess.h	/^        int mate_score;$/;"	m	class:Chess
max_time	./Chess.h	/^        int start_time, stop_time, max_time, movetime;$/;"	m	class:Chess
move	./Chess.h	/^            int move;$/;"	m	struct:Chess::move_t
move	./Chess.h	/^        struct move {$/;"	s	class:Chess
move	./Hash.h	/^            int move;$/;"	m	struct:Hash::__anon2
move2str	./Util.cpp	/^char* Util::move2str(char* move_str, int move) {$/;"	f	class:Util
move_from	./Chess.h	/^            int move_from;$/;"	m	struct:Chess::move
move_number	./Chess.h	/^        int move_number;$/;"	m	class:Chess
move_str	./Chess.h	/^        char move_str[6];$/;"	m	class:Chess
move_t	./Chess.h	/^        struct move_t {$/;"	s	class:Chess
move_to	./Chess.h	/^            int move_to;$/;"	m	struct:Chess::move
movelist	./Chess.h	/^        struct move movelist[MAX_MOVES];$/;"	m	class:Chess	typeref:struct:Chess::move
moves	./Chess.cpp	/^    int moves[1000];$/;"	m	struct:best_lines	file:
movetime	./Chess.h	/^        int start_time, stop_time, max_time, movetime;$/;"	m	class:Chess
n	./Chess.h	/^        int n;$/;"	m	class:Chess
nodes	./Chess.h	/^        unsigned long long nodes;$/;"	m	class:Chess
not_enough_material	./Table.cpp	/^bool Table::not_enough_material() {$/;"	f	class:Table
not_pawn_move	./Chess.h	/^            int not_pawn_move;$/;"	m	struct:Chess::move
pawn_advantage	./Eval.h	/^        int pawn_advantage     =   10;$/;"	m	class:Eval
perft	./Chess.cpp	/^int Chess::perft(int dpt) {$/;"	f	class:Chess
player_to_move	./Chess.h	/^        int player_to_move; \/\/ 1:white, -1:black$/;"	m	class:Chess
posInHashtable	./Hash.cpp	/^bool Hash::posInHashtable() {$/;"	f	class:Hash
pos_black_figure	./Chess.h	/^            int pos_black_figure[16];$/;"	m	struct:Chess::move
pos_black_king	./Chess.h	/^            int pos_black_king;$/;"	m	struct:Chess::move
pos_white_figure	./Chess.h	/^            int pos_white_figure[16];$/;"	m	struct:Chess::move
pos_white_king	./Chess.h	/^            int pos_white_king;$/;"	m	struct:Chess::move
position_received	./Uci.cpp	/^void Uci::position_received(char* input) {$/;"	f	class:Uci
printStatistics	./Hash.cpp	/^void Hash :: printStatistics(int nodes) {$/;"	f	class:Hash
print_table	./Table.cpp	/^void Table::print_table() {$/;"	f	class:Table
processCommands	./Chess.cpp	/^void Chess::processCommands(char* input) {$/;"	f	class:Chess
processCommands	./Uci.cpp	/^void Uci::processCommands(char* input) {$/;"	f	class:Uci
promotion	./Chess.h	/^            int promotion;$/;"	m	struct:Chess::move
pt	./Table.h	/^        int *pt, *ptt;$/;"	m	class:Table
ptt	./Table.h	/^        int *pt, *ptt;$/;"	m	class:Table
rand64	./Hash.cpp	/^unsigned long long Hash::rand64() {$/;"	f	class:Hash
random_window	./Eval.h	/^        int random_window;$/;"	m	class:Eval
reset_counters	./Hash.cpp	/^void Hash::reset_counters() {$/;"	f	class:Hash
reset_movelist	./Table.cpp	/^void Table::reset_movelist() {$/;"	f	class:Table
root_moves	./Chess.h	/^        struct move_t root_moves[MAX_LEGAL_MOVES];$/;"	m	class:Chess	typeref:struct:Chess::move_t
seldepth	./Chess.h	/^        int depth, seldepth, init_depth, curr_depth, curr_seldepth, gui_depth;$/;"	m	class:Chess
setU	./Hash.cpp	/^void Hash::setU(int u) {$/;"	f	class:Hash
set_hash	./Hash.cpp	/^void Hash::set_hash(Chess* chess) {$/;"	f	class:Hash
setboard	./Table.cpp	/^void Table::setboard(char* input) {$/;"	f	class:Table
sm	./Chess.h	/^        int sm;$/;"	m	class:Chess
sort_alfarray	./Chess.h	/^        int sort_alfarray;$/;"	m	class:Chess
start_game	./Chess.cpp	/^void Chess::start_game() { \/\/ new$/;"	f	class:Chess
start_time	./Chess.h	/^        int start_time, stop_time, max_time, movetime;$/;"	m	class:Chess
stop_received	./Chess.h	/^        bool stop_received;$/;"	m	class:Chess
stop_search	./Chess.h	/^        int stop_search;$/;"	m	class:Chess
stop_time	./Chess.h	/^        int start_time, stop_time, max_time, movetime;$/;"	m	class:Chess
str2move	./Util.cpp	/^int Util::str2move(char move_old[6]) {$/;"	f	class:Util
sum_material	./Eval.cpp	/^int Eval::sum_material(int color) {$/;"	f	class:Eval
table	./Chess.h	/^        Table* table;$/;"	m	class:Chess
tablelist	./Chess.h	/^        int tablelist[MAX_MOVES][120];$/;"	m	class:Chess
test	./main.cpp	/^void test() {$/;"	f
test_calculate_evarray	./main.cpp	/^void test_calculate_evarray(Chess &chess) {$/;"	f
test_calculate_evarray_new	./main.cpp	/^void test_calculate_evarray_new(Chess &chess) {$/;"	f
test_move_h2h4	./main.cpp	/^void test_move_h2h4() {$/;"	f
test_perft	./main.cpp	/^void test_perft() {$/;"	f
test_perft_pos1	./main.cpp	/^void test_perft_pos1(int depth) {$/;"	f
test_perft_startpos	./main.cpp	/^void test_perft_startpos(int depth) {$/;"	f
th_make_move	./Chess.h	/^        std::thread th_make_move;$/;"	m	class:Chess
third_occurance	./Table.cpp	/^bool Table::third_occurance() {$/;"	f	class:Table
u	./Hash.h	/^            int u;$/;"	m	struct:Hash::__anon1
u	./Hash.h	/^            int u;$/;"	m	struct:Hash::__anon2
uci	./Chess.h	/^        Uci* uci;$/;"	m	class:Chess
update_table	./Table.cpp	/^void Table::update_table(int move, bool print) {$/;"	f	class:Table
util	./Chess.h	/^        Util* util;$/;"	m	class:Chess
value	./Chess.cpp	/^    int value;$/;"	m	struct:best_lines	file:
value	./Chess.h	/^            int value;$/;"	m	struct:Chess::move_t
white_double_bishops	./Chess.h	/^            int white_double_bishops;$/;"	m	struct:Chess::move
white_king_castled	./Chess.h	/^            int white_king_castled;$/;"	m	struct:Chess::move
~Chess	./Chess.cpp	/^Chess::~Chess() {$/;"	f	class:Chess
~Eval	./Eval.cpp	/^Eval::~Eval() {$/;"	f	class:Eval
~Hash	./Hash.cpp	/^Hash::~Hash() {$/;"	f	class:Hash
~Table	./Table.cpp	/^Table::~Table() {$/;"	f	class:Table
~Uci	./Uci.cpp	/^Uci::~Uci() {$/;"	f	class:Uci
